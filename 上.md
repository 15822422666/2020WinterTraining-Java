## 0.第一个程序

``` Java
public class HelloWorld {
    /* 第一个Java程序
     * 它将打印字符串 Hello World
     */
    public static void main(String []args) {
        System.out.println("Hello World"); // 打印 Hello World
    }
}
```

在cmd中执行编译、运行

```
C : > javac HelloWorld.java
C : > java HelloWorld 
Hello World
```

编写 Java 程序时，应注意以下几点：

- **大小写敏感**：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。
- **类名**：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 **MyFirstJavaClass** 。
- **方法名**：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。
- **源文件名**：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 **.java**。（如果文件名和类名不相同则会导致编译错误）。
- **主方法入口**：所有的 Java 程序由 **public static void main(String []args)** 方法开始执行。

## 1.基本数据类型

四类八种数据类型

**1、整型**

byte 、short 、int 、long

**2、浮点型**

float 、 double

**3、字符型**

char

**4、布尔型**

boolean



需要注意`float`类型在书写时是要带上后缀`f`，例如`1.2f`，否则默认为`double`类型。`long`类型也加上后缀`L`，例如`1000000L`。

此外，由于浮点数类型存储方式原因，在比较两个浮点数是否相同时，应该考虑到它的存储误差。比较他们的值是最好使用做差，限制在允许误差范围内认为两个值相等。

基本类型（与其对应的非基本类型，称为复合类型）：

| 类型名称     | 关键字  | 占用内存 | 取值范围                                   |默认值|
| ------------ | ------- | -------- | ------------------------------------------ |----|
| 字节型       | byte    | 1 字节   | -128~127(-2^7~2^7-1)                       |0|
| 短整型       | short   | 2 字节   | -32768~32767                               |0|
| 整型         | int     | 4 字节   | -2147483648~2147483647                     |0|
| 长整型       | long    | 8 字节   | -9223372036854775808L~9223372036854775807L |0L|
| 单精度浮点型 | float   | 4 字节   | +/-3.4E+38F（6~7 个有效位）                |0.0f|
| 双精度浮点型 | double  | 8 字节   | +/-1.8E+308 (15 个有效位）                 |0.0d|
| 字符型       | char    | 2 字节   | ISO 单一字符集                             ||
| 布尔型       | boolean | 1 字节   | true 或 false                              |false|

查看基本类型的情况
```Java
// byte  
System.out.println("基本类型：byte 二进制位数：" + Byte.SIZE);  
System.out.println("包装类：java.lang.Byte");  
System.out.println("最小值：Byte.MIN_VALUE=" + Byte.MIN_VALUE);  
System.out.println("最大值：Byte.MAX_VALUE=" + Byte.MAX_VALUE);  
```
类型转换：

### 1.1 包装类

 Java中的基本类型功能简单，不具备对象的特性，为了使基本类型具备对象的特性，所以出现了包装类，就可以像操作对象一样操作基本类型数据。

| 基本类型 | 包装类型  |
| -------- | --------- |
| byte     | Byte      |
| int      | Integer   |
| short    | Short     |
| long     | Long      |
| float    | Float     |
| double   | Double    |
| boolean  | Boolean   |
| char     | Character |

包装类主要是两种方法，一种是本类型和其它类型之间进行转换，另一种是字符串和本类型以及基本类型之间的转换

```Java
// 包装类
public class Wrapper {
    public static void main(String[] args) {
        // 装箱：将基本类型转换成包装类
        int a = 1;
        Integer v1 = new Integer(a);    // 手动装箱
        Integer v2 = a;                 // 自动装箱

        // 拆箱：将包装类型转成基本类型
        int b = v1.intValue();      // 手动拆箱
        int c = v2;                 // 自动拆箱

        // 包装类用法一：本类型与其他类型转换
        Integer v3 = 3;
        System.out.println("v3-->" + v3);
        float f1 = v3.floatValue();
        System.out.println("f1-->" + f1);
        byte b1 = v3.byteValue();
        System.out.println("b1-->" + b1);
        String str1 = v3.toString();
        System.out.println("str1-->" + str1);
        System.out.println();

        // 包装类用法二：字符串和本类型以及基本类型之间的转换
        String str2 = "122";
        int i1 = Integer.parseInt(str1);
        System.out.println("i1-->" + i1);
        float f2 = Float.parseFloat(str2);
        System.out.println("f2-->" + f2);
        float f3 = 3.1f;
        String str_f2 = String.valueOf(f3);
        System.out.println("str_f2-->" + str_f2);
        
    }
}
```

## 2.运算符

运算符基本与C语言的运算符相同，这里不过多介绍。


- 算术运算符

- 关系运算符

- 位运算符

- 逻辑运算符

- 赋值运算符

- 条件运算符（?:）

- instanceof 运算符

  该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。

  1. 左侧对象是右侧对象子类，则返回为真

     ```java
     String name = "James";
     boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
     ```

     

  2. 左侧对象兼容右侧对象，则返回为真

     ``` Java
     class Vehicle {}
      
     public class Car extends Vehicle {
        public static void main(String[] args){
           Vehicle a = new Car();
           boolean result =  a instanceof Car;
           System.out.println( result);
        }
     }
     ```



### 2.1 比较`==`与`equals`区别

- #### ==

  对于基本数据类型，比较它们的值是否相同。对于复合数据类型，则比较它们的存放地址是否相同。

- #### equals()方法

  1. Object类中定义的equals方法，实现方式是用`==`运算。因此，Object类的equals方法是比较对象的内存地址是否一致。
  2. 由于Java中所有类都继承自Object这个基类，因此继承它的类可能会复写`equals`方法，所以可能不在是比较其在内存中存储的地址。

``` java
public class EqualCompare {
    public static void main(String[] args) {
        // 基本数据类型
        int a1 = 1;
        Integer a2 = 1;
        int b1 = 1;
        Integer b2 = 1;

        System.out.println(a1 == b1);
        System.out.println(a2.equals(b2));
        System.out.println();

        String s1 = "123";  // 存放在常量池
        String s11 = "123";
        String s2 = new String("123");  // 存放在堆中
        System.out.println(s1 == s11);
        System.out.println(s1 == s2);
        System.out.println(s1.equals(s2));
    }
}
```



**附加材料：[Java内存分配之堆、栈和常量池](<https://www.cnblogs.com/SaraMoring/p/5687466.html>)**

![](https://images2015.cnblogs.com/blog/908514/201607/908514-20160720101024841-238269977.jpg)

## 3. 类

- 类：类是一个模板，它描述一类对象的行为和状态。
- 对象：对象是类的一个实例

### 3.1 访问控制修饰符

- **private** : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**
- **public** : 对所有类可见。使用对象：类、接口、变量、方法
- **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**。

- 使用修饰符时，与`protected`修饰符效果相同

### 3.2 继承 extends

继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

- 生活中的继承

  ![](https://www.runoob.com/wp-content/uploads/2013/12/14B0951E-FC75-47A3-B611-4E1883887339.jpg)

- 类和类之间存在一些共有的属性，那么可以将这些共有的属性抽象成为一个基类。然后这些不同的类可以继承这个基类，在修改共有的属性时，只需要在基类中修改即可。

- 继承类型

![](https://www.runoob.com/wp-content/uploads/2013/12/types_of_inheritance-1.png)

#### 3.2.1 this/super

- this表示当前对象

  用法：

  - 作为对象，它表示当前对象的一个引用，因此可以通过 `this.` 来明确调用当前类的某个方法或字段
  - 作为方法，它表示调用构造方法
  - 在匿名类或内部类时，可以用 `类名.this.` 来明确调用它的外部类某个方法或字段

- super 表示当前对象的父对象。不支持通过 `super.super` 调用父对象的父对象

  用法：

  - 作为对象，它表示父类对象的一个引用，因此可以通过 `super.` 来明确调用父类类的某个方法或字段
  - 作为方法，它表示调用父类构造方法
  - 在匿名类或内部类时，可以用 `类名.super.` 来明确调用它的外部类的父类的某个方法或字段

#### 3.2.2 封装

在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。

封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。

要访问该类的代码和数据，必须通过严格的接口控制。

封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。

适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。

**封装的优点**

- 1. 良好的封装能够减少耦合。
- 2. 类内部的结构可以自由修改。
- 3. 可以对成员变量进行更精确的控制。
- 4. 隐藏信息，实现细节。



### 3.3 抽象类

- abstract   关键字

如果一个类拥有抽象方法, 这个类必须是抽象类  抽象类未必有抽象方法
子类继承一个抽象类,如果子类不希望也成为抽象类,就必须实现父类中所有的抽象方法

**抽象类总结规定**

- 1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
- 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
- 3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
- 4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
- 5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。





### 3.4  接口 interface

刚刚的抽象类中存在抽象方法，但它任然是一个类。而Java只支持单继承，不支持多继承。如果要继承多个类，那么有一个选择，它就是接口。

- 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

- 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

- 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。



### 3.5 多态

多态是同一个行为具有多个不同表现形式或形态的能力。
多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：
![](https://www.runoob.com/wp-content/uploads/2013/12/dt-java.png)
多态性是对象多种表现形式的体现。



**多态存在的三个必要条件**

- 继承
- 重写
- 父类引用指向子类对象

#### 3.5.1 重写（Override）

子类与父类方法名，这时发生了方法重写。

当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。

**方法的重写规则**

- 参数列表必须完全与被重写方法的相同。
- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
- 父类的成员方法只能被它的子类重写。
- 声明为 final 的方法不能被重写。
- 声明为 static 的方法不能被重写，但是能够被再次声明。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写。
- 如果不能继承一个方法，则不能重写这个方法。

#### 3.5.2 重载（Overload）

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

**重载规则:**

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。

### 3.6 静态代码块(static) 和 fianl关键字

- static
  - 属性:静态属性 全类共有 可以用类名直接访问
  - 方法:类名调用   静态方法中只能访问类的静态成员,不能出现this
    - 静态方法只能被子类的静态方法覆盖,而且没有多态  (只根据引用类型,调用相应的静态方法)
  - 初始代码块:静态初始代码块在类加载的时候执行
    - 类加载:当JVM第一次使用一个类时,读入这个类所对应的.class文件,并保存起来
    - 类加载的时机: 1)创建对象  2)加载子类,需要先加载父类  3)访问静态成员  4)Class.forName("类名")
    - 如果只是声明一个类的引用,不需要类加载
  - 类加载的步骤:
    - 1)如果需要,先加载父类
    - 2)按顺序初始化静态属性,或执行静态初始代码块

- final
   变量:常量 一旦赋值,不可改变
        final修饰属性的时候,该属性就没有默认值,就必须手动赋值 
   方法:final方法不能被子类覆盖





----

## 4.异常







## 5. 集合框架







## 6.泛型





# 参考

- [菜鸟教程](<https://www.runoob.com/java/java-tutorial.html>)
- [卢瑞峰Java第一次培训]([https://lab.kenvix.com/topic/46/2019-java-%E5%9F%B9%E8%AE%AD%E8%B5%84%E6%96%99/3](https://lab.kenvix.com/topic/46/2019-java-培训资料/3))



